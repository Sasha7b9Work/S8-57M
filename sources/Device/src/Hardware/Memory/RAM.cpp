// (c) Aleksandr Shevchenko e-mail : Sasha7b9@tut.by
/*
    Здесь работа с памятью на макете, где не было внешней RAM
*/

#include "defines.h"
#include "Display/Console.h"
#include "Display/Painter.h"
#include "Hardware/Timer.h"
#include "Hardware/HAL/HAL.h"
#include "Hardware/Memory/ExtRAM.h"
#include "Hardware/Memory/IntRAM.h"
#include "Hardware/Memory/RAM.h"
#include "Osci/DeviceSettings.h"
#include "Osci/Osci.h"
#include "Utils/Math.h"
#include <cstring>
#include <cstdlib>


#define BEGIN ((uint)ExtRAM::Begin())
#define END   ((uint)ExtRAM::End())


int16 RAM::currentSignal = 0;
Packet *RAM::oldest = (Packet *)BEGIN;
Packet *RAM::newest = nullptr;


bool RAM::needNewFrame = true;


// Записывает по адресу dest. Возвращает адрес первого байта после записи
static uint *WriteToRAM(uint *dest, const void *src, int size)
{
    HAL_BUS::ConfigureToFSMC();
    
    uint8 *address = (uint8 *)dest;

    std::memcpy(address, src, (uint)(size));
    
    return (uint *)(address + size);
}


bool RAM::canTrace = false;


struct Packet
{
    // Адрес следующего пакета, более "свежего". Если addrNext == 0x00000000, следующего пакета нет, этот пакет самый новый
    uint addrNewest;

    bool IsValid()
    {
        return (uint8 *)this >= ExtRAM::Begin() && (uint8 *)this < ExtRAM::End();
    }

    void Trace(uint)
    {
        if(addrNewest == 0 && RAM::canTrace)
        {
            addrNewest = addrNewest; //-V570
        }
    }

    // Упаковать данные по адресу this. Возвращает указатель на пакет, следующий за ним
    void Pack(const DataSettings *ds)
    {
        DataSettings data = *ds;
        data.ch_a = nullptr;
        data.ch_b = nullptr;

        addrNewest = 0x0000000;                                                                         // Указываем, что это самый последний пакет

        uint *address = (uint *)(Address() + sizeof(Packet));                           // По этому адресу запишем DataSettings

        address = WriteToRAM(address, ds, sizeof(DataSettings));                                        // Записываем DataSettings

        if (ds->en_a)                                                                                // Записываем данные первого канала
        {
            data.ch_a = (uint8 *)address;
            address = WriteToRAM(address, ds->ch_a, ds->BytesInChannel());
        }

        if (ds->ch_b)                                                                                  // Записываем данные второго канала
        {
            data.ch_b = (uint8 *)address;
            WriteToRAM(address, ds->ch_b, ds->BytesInChannel());
        }

        std::memcpy((uint *)(Address() + sizeof(Packet)), &data, sizeof(DataSettings)); // Записываем скорректированные настройки
    }
    // Подготовить пакет для сохранения данных в соответствии с настройками ds
    void Prepare(DataSettings *ds)
    {
        int bytesInChannel = ds->BytesInChannel();

        addrNewest = 0x00000000;
        uint *address = (uint *)(Address() + sizeof(Packet));

        ds->ch_a = nullptr;
        ds->ch_b = nullptr;
        uint8 *addrData = (uint8 *)((uint8 *)address + sizeof(DataSettings));

        if (ds->en_a)
        {
            ds->ch_a = addrData;
            std::memset(addrData, VALUE::NONE, (uint)(bytesInChannel));
            addrData += bytesInChannel;
        }

        if (ds->en_b)
        {
            ds->ch_b = addrData;
            std::memset(addrData, VALUE::NONE, (uint)(bytesInChannel));
        }

        WriteToRAM(address, ds, sizeof(DataSettings));
    }

    uint Address() const
    {
        return (uint)this;
    };
    // Возвращает адрес первого следующего за пакетом байта
    uint End() const
    {
        return Address() + Size();
    }
    // Возвращает размер памяти, необходимой для хранения данных в соответсвии с настройками ds
    static int NeedMemoryForPacedData(const DataSettings *ds)
    {
        uint size = sizeof(Packet) + sizeof(DataSettings) + ds->NeedMemoryForData();

        return (int)(size);
    }

    int Size() const
    {
        uint size = sizeof(Packet) + sizeof(DataSettings) + GetDataSettings()->NeedMemoryForData();

        return (int)(size);
    }

    DataSettings *GetDataSettings() const
    {
        uint address = Address() + sizeof(Packet);

        return (DataSettings *)address;
    }
};


void RAM::Init()
{
    oldest = (Packet *)BEGIN;
    newest = nullptr;
}


DataSettings *RAM::PrepareForNewData()
{
    if(OSCI_IN_MODE_RANDOMIZER &&           // В рандомизаторе иногда будем возвращать указатель на последние считанные данные
       (NumberDatas() != 0) &&              // Но только если в хранилище они есть
       !needNewFrame)                       // И если прямо не заявлено подготовить новый фрейм
    {
        return Get();
    }

    DataSettings ds;

    ds.Fill();

    ds.id = NumberDatas() ? Get()->id + 1 : 0;

    uint address = AllocateMemoryForPacket(&ds);    // Находим адрес для записи нового пакета

    if (newest)
    {
        newest->addrNewest = address;               // Указываем его в качестве адреса следующего пакета для предыдущего
    }

    newest = (Packet *)address;                     // Устанавилваем этот адрес в качестве новейшего пакета

    newest->Prepare(&ds);                           // И упаковываем данные

    DataSettings *result = Get();

    result->timeMS = TIME_MS;

    if(OSCI_IN_MODE_RANDOMIZER && 
       (NumberDatas() != 0))
    {
        if (OSCI_IN_MODE_RANDOMIZER && (SampleType::IsReal() || S_TRIG_START_MODE_IS_SINGLE))
        {
            result->Clear();
        }
        else
        {
            if (result->IsEquals(*Get(1)))
            {
                result->CopyDataFrom(Get(1));
            }
        }

        needNewFrame = false;
    }

    return result;
}


DataSettings *RAM::Get(int numFromEnd)
{
    int number = NumberDatas();
    
    if (numFromEnd + 1 > number)
    {
        return nullptr;
    }

    int counter = number - 1 - numFromEnd;

    Packet *packet = oldest;

    while (counter > 0)
    {
        packet = (Packet *)packet->addrNewest;
        counter--;
    }

    return packet->GetDataSettings();
}


int RAM::NumberDatas()
{
    HAL_BUS::ConfigureToFSMC();

    if (newest == nullptr)
    {
        return 0;
    }

    if (oldest == nullptr)
    {
        return 1;
    }

    int result = 0;

    Packet *packet = oldest;

    while (packet != nullptr)
    {
        result++;

        packet = (Packet *)packet->addrNewest;

//        if(packet != nullptr && !packet->IsValid())     // \todo Времення затычка. Нужно разобраться, почему память портится и исправить
//        {
//            LOG_WRITE("invalid packet 0x%x", packet);
//            break;
//        }
    }

    return result;
}

uint RAM::AllocateMemoryForPacket(const DataSettings *ds)
{
    if (newest == nullptr)                                                  // Ещё нет ни одной записи
    {
        return BEGIN;
    }

    uint addrFirst = newest->End();                                         // По этому адресу должна быть следующая запись
    uint addrLast = addrFirst + Packet::NeedMemoryForPacedData(ds);         // А это последний байт следующей записи

    if (addrLast > END)
    {
        addrLast = BEGIN + Packet::NeedMemoryForPacedData(ds);
        while ((uint)oldest < addrLast)
        {
            RemoveOldest();
        }
        return BEGIN;
    }
                                                                            
    if (newest > oldest)                                                    // Нормальный порядок следования - более новые записи расположены после более старых
    {                                                                       
        if (addrLast < END)                                                 // Если хватает памяти для записи
        {
            return addrFirst;
        }
        else                                                                // Если остатка памяти не хватает для сохранения записи
        {
            AllocateMemoryFromBegin(Packet::NeedMemoryForPacedData(ds));    // То освобождаем в начале памяти необходимое число байт для хранения пакета

            return BEGIN;
        }
    }

    if (newest < oldest)                                                    // Более старые записи расположены после более новых
    {
        while (addrLast >= (uint)oldest)
        {
            RemoveOldest();
            if (oldest->Address() == BEGIN)
            {
                break;
            }
        }
    }

    return addrFirst;
}


void RAM::AllocateMemoryFromBegin(int size)
{
    while (oldest->Address() - BEGIN < (uint)(size))
    {
        RemoveOldest();
    }
}


void RAM::RemoveOldest()
{
    oldest = (Packet *)oldest->addrNewest;
}


bool RAM::LastSettingsEqualsCurrent()
{
    if(NumberDatas() == 0)
    {
        return false;
    }

    DataSettings *last_data = Get();

    return last_data ? last_data->EqualsCurrentSettings() : false;
}
